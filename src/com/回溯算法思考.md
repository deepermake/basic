# 回溯算法
## 基本思想
+ 选择：从可行的选择中做出一个决策。
+ 约束：在做出选择后，检查该选择是否满足约束条件。
+ 推进：如果当前选择有效，就继续推进到下一个决策点。
+ 回退：如果当前选择不符合要求，撤销当前的选择，回到上一步重新做选择。

## 经典场景
+ 求解组合问题：如子集、排列、组合等。
+ 路径搜索：如迷宫问题、棋盘问题。
+ 图的搜索：如图的着色问题、Hamiltonian路径问题等。
+ 数独：通过回溯填充数独的每一个格子，逐步尝试直到填满。
+ 八皇后问题：在棋盘上放置8个皇后，使得它们互不攻击。

## 回退条件
+ 当前条件不符合约束条件：在逐步推进的过程中，如果某一步选择不满足问题的要求（如冲突、越界），就需要回退
+ 尝试所有可能的选择：当某一选择导致无法继续推进时，必须回退到上一个决策点，尝试下一个可能的选择。
+ 所有选择都已尝试完毕：当一个决策层级的所有选择都已经尝试过并且都失败时，回退到上一层


    // 全局结果集合
    List<List<Integer>> result = new ArrayList<>();
    // 临时路径记录
    List<Integer> path = new ArrayList<>();
    
    void backtracking(参数列表) {
        // 终止条件：达到目标状态时记录结果
        if (满足终止条件) {
            result.add(new  ArrayList<>(path));
            return;
        }
        // 遍历选择列表 
        for (选择 : 当前可选集合) {
            // 剪枝：排除不合法选择（可选）
            if (不满足约束条件) continue;
            
            // 做出选择 
            path.add( 选择);
            // 递归进入下一层决策树 
            backtracking(新参数);
            // 撤销选择（回溯核心）
            path.remove(path.size()  - 1);
        }
    }