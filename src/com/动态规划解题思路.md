动态规划（Dynamic Programming, DP）是一种常用的算法设计技巧，适用于解决具有重叠子问题和最优子结构性质的问题。以下是动态规划的解题思路：

+ 确定子问题：将原问题分解为更小的子问题，识别出需要解决的子问题。

+ 定义状态：用一个数组或表来存储子问题的解，通常用 dp[i] 或 dp[𝑖][𝑗]来表示与子问题相关的状态。

+ 设定状态转移方程：找到如何通过已经解决的子问题来构建当前子问题的解。转移方程是动态规划的核心，通常涉及对之前状态的某种组合。

+ 初始化：设定初始状态，通常是一些基本情况的解，比如边界条件。

+ 计算顺序：根据状态转移方程的性质，确定计算子问题的顺序，通常是自下而上的顺序（从小到大）或自上而下的递归形式（带记忆化）。

+ 提取结果：从存储子问题解的数组或表中获取最终结果。

理解状态转移方程
重叠子问题：在动态规划中，许多子问题会重复计算。因此，我们需要找到一种方式，将这些子问题的解存储起来，以便在需要时直接使用。

最优子结构：这意味着一个问题的最优解可以通过其子问题的最优解来得到。

示例分析
以“0/1 背包问题”为例来说明状态转移方程的设定。

问题：给定一组物品，每个物品有重量和价值，背包的最大承重为 W，求可以装入背包的最大价值。

状态定义：设 dp[i][w] 表示前 i 个物品在重量不超过 w 时的最大价值。

转移方程：

+ 如果不选第 i 个物品，价值为 dp[i-1][w]。
+ 如果选第 i 个物品，价值为 value[i] + dp[i-1][w-weight[i]]（前提是 weight[i] ≤ w）。
  所以，转移方程可以写为：
  dp[i][w]=max(dp[i−1][w],value[i]+dp[i−1][w−weight[i]])

初始化：

+ dp[0][w] = 0 表示没有物品时的最大价值为 0。
+ dp[i][0] = 0 表示重量为 0 时的最大价值为 0。

# 字符串动态规划问题解题思路

## 1.明确问题

### 将问题转化为一个**状态定义**和**状态转移关系**的问题。

## 2.核心解题框架

### (1) 状态定义

### 设dp[𝑖][𝑗]表示字符串相关问题的状态

* ### i 和 j 通常是字符串下标，用于表示部分问题的子状态。
* ### dp[𝑖][𝑗]的意义需要结合问题具体定义。

### (2) 状态转移方程

### 推导如何从较小的子问题状态转移到当前状态。

* ### 基础场景：通常是空字符串或字符串的某一端。
* ### 递推规则：结合具体问题，基于字符串匹配、不匹配或操作（如插入、删除、替换）进行状态更新。

### (3) 初始条件和边界

* ### 初始化数组 dp[𝑖][𝑗]的边界值。
* ### 处理空字符串的情况。

### (4) 结果计算

* ### 问题的最终结果通常可以从dp的最后一个状态dp[m][n]或通过对整个dp表的某些状态进行扫描获得。

# 字符串动态规划常见题型

## 1、倒推法，从结果出发，根据预设结果反推条件

516-最长回文子序列
62-不同路径 
以及相关涉及多路径的题型

## 2、长度法（针对回文串题型）


## 3、从多条件到少条件法
221-最大正方形，从面积到边长，从二维到一维，简化条件