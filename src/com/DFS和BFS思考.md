# DFS （ 深度优先搜索 ）
## 一条路走到黑，退回来再试下一条。  
### 一、DFS回溯的核心问题
DFS通过路径记录和状态回溯解决“记住上一个岔路”的问题。当遇到死胡同时，算法会沿着记录的路径原路返回，知道找到最近未探索完的岔路口，继续尝试其他分支。
### 二、实现方式
#### 1. 显式栈（ 手动维护路径 ）
通过数据结构栈（ stack ） 保存当前路径。每次访问新节点时将其压入栈，遇到死胡同则弹出栈顶元素，回到上一个节点继续探索其他分支。    
    

    stack = [(起点坐标)]
    visited = set()  # 记录已访问节点
    while stack:
        current = stack.pop()
        if current是终点: 返回路径
        for 每个相邻节点 in current的邻接节点:
            if 节点未访问且可通行:
                stack.append(节点)
                visited.add(节点)
#### 2. 递归 （ 隐式系统调用栈 ）
利用函数调用栈自动保存路径。递归进入一个节点相当于压栈，函数返回 （ 递归终止 ） 相当于弹栈回溯。


    void dfs(int step) {
        if (到达终点) return;  // 终止条件
        for (每个可能的岔路方向) {
            if (该方向未被访问) {
                标记为已访问;
                dfs(step + 1);  // 递归进入下一层
                取消标记;        // 回溯到上一层
            }
        }
    }
### 三、 关键实现细节
#### 1、 状态标记与恢复
* 访问过的节点需要标记 （ 如visited数组 ） ，避免重复访问。
* 回溯时需要撤销标记 （ 如迷宫问题中 “ 拆墙 ”  ） ，否则后续路线可能被错误阻塞
# BFS （ 广度优先搜索 ） 
## 一群人排着队，一层一层扫雷式探索。


# 解题技巧
有多少条路，走多少条路。