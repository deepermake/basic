# 递归算法

> 递归算法的核心思路其实很想“自己调用自己，但每次都离答案更近一步”。如果一个大问题拆成结构相同的子问题，并且能明确终止条件，那么它就很可能适合用递归来解决。

## 一、递归的三要素

### 1. 终止条件（Base Case）

+ 防止无限调用自己
+ 当问题规模足够小、答案显而易见时直接返回结果
+ 类似“走楼梯走到最后一级"或“数组只剩一个元素”

### 2. 递归公式（递归关系）

+ 把大问题拆成结构相同但规模更小的子问题
+ 例如：f(n) = f(n-1) + f(n-2)
+ 关键是：子问题和原问题的解法结构一样

### 3. 数据规模变化（收敛性）

+ 每次递归调用，问题规模必须变小
+ 比如n变成n-1,或者区间[1, r]缩小
+ 这保证递归一定会走到终止条件

## 二、判断一个问题是否适合递归

+ Q1 这个问题能不能被拆成更小的”同类问题“？
+ Q2 能不能找到”最小问题“的直接答案？
+ Q3 每次拆分时，规模会不会越来越小直到最小问题？

## 三、 套用递归的步骤

### 1. 找结构重复性

+ 举例：求n!

       5! = 5 × 4!
       4! = 4 × 3!
       ...
       1! = 1

### 2. 写出递归关系式

+ 把公式抽象成f(n) = 5 * f(4)这样的形式

### 3. 确定终止条件

+ n = 1 时直接返回

### 4. 实现递归函数

+ 用代码写出公式和终止条件